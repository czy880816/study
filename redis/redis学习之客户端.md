# 一、客户端API

## 1、client list

client list命令能列出与redis服务端相连的所有客户端连接信息

输出结果的每一行代表已饿客户端信息，可以看到每行包含了十几个属性，常见的如下：

### 1）标识：

id、addr、fd、name 这四个 标示属于客户端标示

a、id：客户端连接的唯一标识，这个id是随着redis的连接自增的，重启redis后会重置为0

b、addr：客户端连接的ip和端口

c、fd：socket的文件描述符，与lsof命令结果中的fd是同一个如果fd=-1代表当前客户端不是外部客户端，而是redis内部的伪装客户端

d、name：客户端的名字，后面的client setName和client getName两个命令会对其进行说明

### 2）输入缓冲区：

qbuf、qbuf-free

redis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时redis会从输入缓冲区拉取命令并执行，输入缓冲区为客户端发送命令到redis执行命令提供了缓冲功能

client list命令中qbuf和qbuf-free分别代表这个缓冲区的总容量和剩余容量，redis没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小的不同动态调整，只是要求每个客户端缓冲区的大小不能超过1G，超过后客户端将被关闭

输入缓冲区使用不当会产生两个问题：

- 一旦某个客户端的输入缓冲区超过1G，客户端将会被关闭。
- 输入缓冲区不受maxmemory控制，假设一个redis实例设置了maxmemory为4G，已经存储了2G数据，但是如果此时输入缓冲区使用了3G，已经超过maxmemory限制，可能会产生数据丢失、键值淘汰、OOM等情况

造成输入缓冲区过大的原因有哪些：

- redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的bigkey
- redis发生了阻塞，短期内不能处理命令，造成了客户端输入的命令积压在了输入缓冲区

### 3）输出缓冲区

obl、oll、omem

redis为每个客户端分配了输出缓冲区，它的作用是保存命令执行的结果返回给客户端

与输入缓冲区不同，输出缓冲区可以通过client-output-buffer-limit来进行设置，并且输出缓冲区按照客户端的不同分为三种：普通客户端、发布订阅客户端、slave客户端

和输入缓冲区相同的是，输出缓冲区也不会受到maxmemory的限制，如果使用不当同样会造成maxmemory用满产生的数据丢失、键值淘汰、OOM等情况

输出缓冲区由两部分组成：

- 固定缓冲区（16kb）：返回比较小的执行结果
- 动态缓冲区：返回比较大的结果

固定缓冲区使用的是子节数组，动态缓冲区使用的是列表。当固定缓冲区存满后会将redis新的返回结果存放在动态缓冲区的队列中，队列中的每个对象就是每个返回结果

obl：代表固定缓冲区的长度，对象个数

oll：代表动态缓冲区列表的长度，对象个数

omem：代表使用的子节数

### 4）客户端的存活状态

client list中的age和idle代表当前客户端已经连接的时间和最近一次空闲的时间，单位为s

### 5）客户端的限制

maxclients：用来限制最大客户端的连接数，一旦连接数超过maxclients，新的连接将被拒绝。maxclients默认值为10000，可以通过info clients来查询当前redis的连接数,可以通过config set maxclients对最大客户端连接数进行动态配置

一般来说maxclients=10000在大部分场景下已经绝对够用，但是某些情况由于业务放方使用不当可能存在大量idle连接，无论是从玩过连接的成本还是超过maxclients的后果来说都不是什么好事，因此redis提供了timeout（单位为s）参数来限制连接的最大空闲时间，一旦客户端连接的idle时间超过了timeout，连接将会被关闭