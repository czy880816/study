# **一**、缓存的收益和成本

## 1、缓存的收益

1）加速读写

2、降低后端负载

## 2、成本

1）数据不一致性

2）代码维护成本

3）运维成本

## 3、使用场景

1）开销大的复杂计算

2、加速请求响应：redis每秒可以完成几万次的读写，并且提供的批量操作可以优化整个IO链的响应时间

# 二、缓存更新策略

## 1、LRU/LFU/FIFO算法剔除

**使用场景：**通常用于缓存使用量超过了预设的最大值的时候

**一致性：**最差

**维护成本：**只需要配置maxmemory和对应的策略即可

## 2、超时剔除

**使用场景：**如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以设置过期时间。在数据过期后，再从真实数据源获取数据，重新放到缓存病设置过期时间

**一致性：**一段时间窗口内存在一致性问题

**维护成本：**较低，只需要设置expire过期时间即可

## 3、主动更新

**使用场景：**应用方对于数据的一致性要求较高，需要在真实数据更新后，立即更新缓存数据

**一致性：**一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超市剔除一起使用效果会更好

**维护成本：**维护成本比较高，开发需要自己来完成更新，病保证更新操作的正确性

## 4、最佳实践

- 低一致性业务建议配置最大内存和淘汰策略方式使用
- 高一致性业务可以结合使用超时剔除和主动更新，这样即使更新出了问题，也能保证数据过期时间后删除脏数据

# 二、穿透优化

缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常处于容错的考虑，如果从存储层查不到数据则不写入缓存层

造成缓存穿透的原因有两个

- 自身业务代码或者数据出现问题
- 一些恶意攻击、爬虫等造成大量空命中

解决缓存穿透问题的几个方案：

**1、缓存空对象：**如果存储层不命中，则仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源

缓存空对象会有连个问题：

- 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除
- 缓存层和存储层的数据会有一段时间窗口不一致，可能会对业务有一定的影响

**2、布隆过滤器拦截：**在访问缓存层和存储层之前，讲存在的key用布隆过滤器提前保存起来，做一层拦截，redis可以利用Bitmaps实现布隆过滤器

这种方式适用于数据命中不高，数据相对固定，实时性较低的应用场景，代码维护较为复杂，但是缓存空间占用小