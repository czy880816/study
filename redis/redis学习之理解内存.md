# 一、内存消耗

## 1、内存消耗的划分

Redis进程内消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片,如下图所示：

![](/Users/lixiaojie/github/study/pictures/redis内存消耗划分-1.png.png)

1）对象内存是redis内存占用最大的一块，存储着用户所有的数据

redis所有的数据都是采用k-v数据类型，每次创建键值对时，至少创建两种类型的对象，键对象使用的是字符串，在使用redis时很容易忽略健对内存消耗的影响，应当避免使用过长的键。value对象复杂些，包括五种数据类型。其他数据类型都是建立在这五种数据类型之上实现的，如Bitmaps和HyperLogLog都是使用字符串实现，GEO使用有序集合实现等。

2）缓冲内存：

缓冲区内存主要包括**客户端缓冲**、**复制积压区缓冲区**、**AOF缓冲区**

**客户端缓冲**指的是所有接入redis服务器的tcp链接的输入输出缓冲。输入缓冲无法控制，最大空间1G，如果超过将断开连接，输出缓冲通过参数client-output-buffer-limit控制

**复制积压缓冲区**整个redis主节点只有一个，所有的从节点共享此缓冲区，因此可以设置较大的缓冲区空间，以防止全量复制

**AOF缓冲区**：这部分空间用于在redis重谢期间保存最近的写入命令。AOF缓冲区用户无法控制，消耗的内存取决于AOF充血时间和写入命令量，这部分空间通常占用很小

3）内存碎片：

以下操作会引起高内存碎片问题：

a、频繁做更新操作

b、大量过期键删除，键对象过期删除后，释放的空间无法得到充分利用，导致碎片率上升

高碎片率的常见解决办法：

a、数据对齐，在条件允许的情况下尽量做数据对齐，比如数据尽量采用数字类型或者固定长度字符串等

b、安全重启：重启节点可以做到内存碎片重新整理，因此可以利用高可用架构，如Sentinel或Cluster，将碎片率过高的主节点转换为从节点，进行安全重启

子进程内存消耗

子进程内存消耗主要指执行AOF/RDB重写时redis创建的子进程内存消耗

# 二、内存管理

## 1、设置内存上限

redis可以泗洪maxmemory参数限制最大可用内存。限制内存的主要目的由：
1）用于缓存系统，当超出内存上限maxmemory时适用LRU等删除策略释放空间

2）防止所有内存超过服务器物理内存

## 2、动态调整内存上限

redis的内存上限可以通过`config set maxmemory`进行动态修改，即修改最大可用内存，通过动态修改内存，可以实现在当前服务器下动态伸缩redis内存的目的

<u>redis默认无限适用服务器内存，为防止极端情况下导致系统内存耗尽，建议所有的redis进程都要配置maxmemory</u>

## 3、内存回收策略

redis的内存回收机制主要体现在以下两个方面：

- 删除到达过期时间的键对象
- 内存使用达到maxmemory上限时触发内存溢出控制策略

### 1）删除过期键对象

​	redis进程内保存大量的键，维护每个键精准的过期删除机制会导致消耗大量的CPU，这对于单线程的redis来说成本过高，因此redis采用惰性删除和定时任务删除机制实现过期键的内存回收

**a、惰性删除：**

惰性删除用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略处于节省CPU考虑，不需要单独维护TTL链表来处理过期键的删除。但是单独使用这种方式存在内存泄漏的问题，当过期键一致没有访问将无法得到及时删除，从而导致内存不能及时释放，因此，redis提供了另一种定时任务删除机制作为惰性删除的补充

**b、定时任务删除：**

redis内部维护一个定时任务，默认每秒运行10次（可以通过配置hz控制）。定时任务中删除过期键逻辑采用自适应算法，根据键的过期比例，适用快慢两种速率模式回收键，流程如下：

i、定时任务在每个数据库空间随机检查20个键，当发现键过期时，删除对应的键

ii、如果超过检查数25%的键过期，循环执行回收逻辑只到不足25%或运行超时为止啊，慢模式下超市时间为25ms

iii、如果之前回收键逻辑超时，则在redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1ms且2s内只能运行1次

iv、快慢两种模式内部删除逻辑相同，只是执行的超时时间不同

### 2）内存溢出控制策略

当redis所用内存达到maxmemory上限时会触发相应的溢出控制策略，具体策略手maxmemory-policy参数控制

redis支持六种策略，如下：

a、**noeviction**：redis的默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，此时redis只响应读操作

b、**volatile-lru**：根据LRU算法删除设置了超时属性的键，直到腾出足够空间为止。如果没有可删除的键对象，会推倒noeviction策略

c、**allkeys-lru**：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止

d、**allkeys-random**：随机删除所有键，直到腾出足够内存为止

e、**volatile-random**：随机删除过期键，直到腾出足够内存为止

f、**volatile-ttl**：根据键值对象的ttl属性，删除最近将要过期的数据。如果没有，回退到noeviction策略

# 三、内存优化

##  1、redisObject对象

redis存储的所有值对象在内部定义为redisObject结构体，redis存储的数据都是使用redisObject来封装，包括string、hash、set、zset、list在内的所有数据类型，redisObject对象包括以下几个字段：

1）type字段：表示当前对象使用的数据类型

2）encoding字段：表示redis内部编码类型

3）lru字段：记录对象最后一次被访问的时间，当配置了maxmemory和maxmemory-policy=volatile-lru或者allkeys-lru时，用于辅助LRU算法删除键数据

4）refcount字段：记录当前对象被引用的次数，用于通过引用次数回收内存，当refcount=0时，可以安全回收当前对象空间

5）*ptr字段：与对象的数据内容有关，如果时证书，直接存储数据；否则表示指向数据的指针

## 2、缩减键值对象

 降低redis内存使用最直接的方式就是缩减键和值的长度

- key长度：在设计键时，在完整描述业务情况下，key越短越好
- value长度：可以把业务对象序列化成二进制数组放入缓存中，但是在使用的过程中要考虑频繁压缩解压计算所带来的开销成本

## 3、共享对象池

共享对象池是指redis内部维护[0-9999]的整数对象池

当设置maxmemory并启用LRU相关淘汰策略时redis禁止使用共享对象池。LRU算法需要获取对象最后被访问的时间，以便淘汰最长未访问的数据，每个对象最后访问时间存储在redisObject对象的lru字段。对象共享意味着多个引用共享同一个redisObject，这时lru字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置maxmemory，直到内存被用尽redis也不会出发内存回收，所以共享对象池可以工作

为什么只有整数共享对象池？

首先整数对象复用的几率大，其次对象共享的一个关键操作就是判断相等性，redis之所以只有整数对象池，是因为整数比较算法的时间复杂度为*O(1)*,只保留一万个整数位了防止对象池浪费。

## 4、字符串优化

//

## 5、控制键的数量

