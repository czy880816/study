#   一 、JAVA内存重排序

## 1、什么是重排序？ 

重排序是编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段 

## 2、重排序的种类有哪些？

1）编译器优化重排序（编译器重排序） 

2）指令级并行重排序（处理器重排序）

3）内存系统的重排序（处理器重排序） 

重排序优缺点： 

优点：提高程序的处理性能 

缺点：可能会出现内存的可见性问题 

## 3、happens-before

- ### happens-before的定义

==1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前（内存的顺序一致性模型）==

==2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序来执行。如果重排序之后的结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。==

- ###  ~~happens-before规则：~~

~~1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作~~ 

~~2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁~~ 

~~2）volatile规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读~~ 

~~3）传递性：如果A happens-before B,且B happens-before C，那么A happens-before C~~ 

JMM的内存屏障策略（L-Load S-Store）

| 类型 | 说明                                                         |
| ---- | :----------------------------------------------------------- |
| LLB  | 确保Load1数据的装载先于Load2及所有后续装载指令的装载         |
| SSB  | 确保Store1数据对其他处理器的可见（刷新到内存）先于Store2及所有后续存储指令的存储 |
| LSB  | 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存    |
| SLB  | 确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 |

~~JMM中happens-before要求禁止的两类重排序：~~

~~1）会改变程序执行结果的重排序~~

~~对于这种重排序，JMM要求编译器和处理器必须禁止~~

~~2）不会改变程序执行结果的重排序~~

~~对于这种重排序，编译器和处理器不做要求~~

- ### as-if-serial与happens-before

1）as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变

2）as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序时按照程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序时按happens-before指定的顺序来执行的。

### happens-before规则

1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读

4）传递性：如果A happens-before B，B happens-before C，那么A happes-before C

5）start()规则：如果线程A执行操作ThreadB.start()(启动线程B)，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作

6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

## 4、什么是数据依赖性？

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。 

## 5、as-if-serial语意 

不管怎么重排序，单线程程序的执行结果不会被改变。 

## 6、什么是数据竞争？ 

在一个线程里写一个变量 

在另一个线程里读同一个变量 

而且写和读没有通过同步来排序 

## 7、JMM模型与顺序一致性模型有什么区别 

1）顺序一致性模式会保证单线程内程序的操作按照程序的顺序执行，而JMM模型不保证单线程内的操作会按照顺序一致性执行 

2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序 

3）JMM不保证对64位long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性 

## 8、总线事物

每次处理器和内存之间的数据传递都是通过一系列的步骤完成的，这一系列的步骤称为总线事物。总线事物包括读事物和写事物，读事物负责从内存传送数据到处理器，写事物从处理器传递数据到内存。 

==总线会同步试图并发使用总线的事物==，也就是说在处理器执行总线事物期间，总线会禁止其他的处理器和I/O设备执行内存的读/写。总线的这种工作机制可以把所有处理器对内存的访问以串行化的方式来执行。也就保证了总线 事物中的内存读/写操作是原子性的。

# 二、volatile的内存语义

## 1、volatile的特性

1）可见性。对于一个volatile的读，总是能看到（任意线程）对这个变量最后的写入

2）原子性。对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性

## 2、volatile的内存语义

1）volatile的写内存语义：

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存

2）volatile的读内存语义

当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

==volatile可以说是线程间通信的一种方式，线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了消息；线程B读取一个volatile变量，实质上是线程B接收了之前某个线程发出的消息。也就是，线程A向线程B发送了消息。==

## 3、关于volatile的重排序规则

1）两个操作中，当第二个操作为volatile写时，不管第一个操作是什么操作，都不能重排序

2）两个操作中，当第一个操作为volatile读时，不管第二个操作是什么操作，都不能重排序

以上两条就是说编译器不会对volatile读与volatile读后面的任意内存操作重排序；也不会对volatile写与volatile写前面的任意内存操作重排序

*注：volatile和锁的区别：*

1）volatile仅仅保证对单个volatile变量的读/写具有原子性（<u>还是可见性？待佐证</u>），而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性

[^脚注]: https://www.ibm.com/developerworks/cn/java/j-jtp06197.html

# 三、锁的内存语义

锁的作用：

1）让临界区互斥执行

2）让释放锁的线程向获取同一个锁的线程发送消息

## 1、锁释放的内存语义

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中

## 2、锁获取的内存语义

当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

综上，线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了消息；线程B获取一个锁，实质上是线程B接收了之前某个线程发出的消息。

j.u.c包的源代码的通用实现模式：

1）声明共享变量为volatile

2）使用CAS的原子条件更新来实现线程间的同步

3）配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信

# 四、final域的内存语义

## 1、final域的重排序规则

1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序

<u>注：写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化了，而普通域不具有这个保障。</u>

2）初次读一个包含final域的对象引用，与随后初次读这个final域，这两个操作之间不能重排序

<u>注：读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象引用</u>

3）对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序

## 2、为什么final引用不能从构造函数内溢出？

因为在构造函数内部，不能让这个被构造对象的引用为其它线程所见

# 五、双重检查锁的内存重排序问题的解决方案

## 1、给类成员加volatile关键字

对象的初始化分为以下几步操作：

1）分配对象的内存空间

2）初始化对象

3）设置指向内存地址的引用

2）和3）之间会发生重排序，导致最后获取到的对象不是一个完整的对象，因此加上volatile可以禁止2）和3）的重排序

## 2、基于类的初始化的解决方案

JVM在类的初始化阶段（即在class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。如下所示：

```java
public class InstanceFactory{
    private static class InstanceHolder{
        public static Instance instance = new Instance();
    }
    
    public static Instance getInstance(){
        return InstanceHolder.instance;//这里将导致InstanceHolder类被初始化
    }
}
```

这种方式，即使发生了如1中的重排序问题，但线程B无法看到这个重排序，因此不会出现该问题。

初始化一个类，包括这个类的静态初始化和初始化在这个类中声明的静态成员。根据java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化。

1）T是一个类，而且一个T类型的实例被创建

2)   T是一个类，且T中声明的一个静态方法被调用

3）T中声明的一个静态成员被赋值

4）T中声明的一个静态成员被使用，而且这个成员不是一个常量成员

5）<u>是一个顶级类，而且一个断言语句嵌套在T内部被执行</u>

<u>java语言规范规定，对于每一类或接口C，都有一个唯一的初始化锁LC与之对应。JVM在类的初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保着这个类已经被初始化过了。</u>

## 3、两种方案的比较

1）类的初始化方案实现上更加简洁

2）volatile的初始化方案，除了可以对静态字段实现延迟初始化外，还可以对实例字段延迟初始化
