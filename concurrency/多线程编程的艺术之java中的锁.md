# 一、Lock接口

Lock接口提供的synchronized关键字不具备的特性

| 特性             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 尝试非阻塞获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其它线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁 | 获取到的锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁       | 在指定截止时间前获取锁，如果截止时间到了仍旧无法获取锁，则返回 |

## 1、队列同步器（AQS）

同步器的设计时基于模版方法模式的,同步器提供的模版方法基本上分为3类：

- 独占式获取与释放同步状态
- 共享式获取与释放同步状态
- 查询同步队列中的等待线程情况

在线程自旋获取状态的时候，只有前驱节点式头节点才能获取同步状态，原因有两个：

- 头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己的前驱节点式否是头节点
- 维护同步队列的FIFO原则

独占同步状态的获取流程如下：

## 2、可重入锁

重入锁，表示该锁能够支持一个线程对资源的重复加锁

实现重进入：

- 线程再次获取锁

  锁需要取识别获取锁的线程是否为当前占据锁的线程如果是，则再次成功获取

- 锁的最终释放

  线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁。也就是说获取几次，释放几次

公平锁与非公平锁：

公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO

非公平锁可能会使线程“饥饿”，但是为什么又被设定成默认实现呢？

通过测试，非公平锁因为某线程再次获取锁的原因，其线程上下文切换次数要比公平锁少很多，因此性能要比公平锁高很多，因此，索然非公平锁虽然可能会造成线饥饿，但极少的线程切换，保证了其更大的吞吐量

## 3、读写锁

读写锁在同一时刻允许多个线程访问，==只是在写线程访问时，所有的读线程和其它写线程均被阻塞==

读写锁的典型实现时ReentrantReadWriteLock，其特性如下：

| 特性       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 公平性选择 | 支持非公平（默认）和公平锁的获取方式，吞吐量还是非公平优于公平 |
| 重进入     | 读锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁 |
| 锁降级     | 遵循获取写锁、获取读锁再释放写锁的顺序，写锁能够降级为读锁   |

读写锁的实现分析：

### 1）读写状态的设计

因为读写锁需要在一个同步状态上维护一个写线程和多个读线程的状态，因此，要想在一个整形变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切割成了两个部分，高16位表示读，低16位表示写。通过位运算迅速定位到读和写各自的状态。

<u>如果当前同步状态值为S，写状态等于S&0x0000FFFF(将高16位全部抹去)，读状态等于S >>> 16(无符号补0右移16位)。当写状态增加1时，等于S+1，当读状态增加1时，等于S + (1<<16)，也就是S + 0x00010000.</u>

根据状态的划分能得出一个推论：S不等于0时，当写状态(S & 0x0000FFFF)等于0时，则读状态(S >>> 16)大于0，即读锁已经被获取。

### 2）写锁的获取与释放

写锁是一个支持重入的排它锁。如果当前线程已经获取到了写锁，则增加写状态。<u>如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）</u>或者<u>该线程不是已经获取写锁的线程</u>，则当前线程进入等待状态。

如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁时可见的，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其它线程就无法感知到当前写线程的操作。因此有如下总结：

- 已经有线程获取到读锁的情况下，再去获取写锁，则写锁被阻塞
- 在已经有其它线程获取到写锁的情况个下，则后续读锁的获取和写锁的获取将被阻塞，如果获取到的写锁的线程就是当前线程，则当前线程仍然可以获取到读锁，也就是锁可重入

### 3）读锁的获取与释放

读锁是一个支持重入的共享锁，它能被多个线程同时获取，在没有其它写新城访问时，读锁总会被成功的获取，而所做的也只是增加读状态。写锁的获取有如下规则：

- 如果当前线程已经获取了读锁，则增加状态
- 如果当前线程在获取读锁时，写锁已经被其它线程获取了，则进入等待状态

### 4）锁降级

锁降级指的是写锁降级为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先拥有的）写锁的过程。

## 4、LockSupport工具

当需要阻塞或者唤醒一个线程的时候，都会用到LockSupport工具来完成相应工作

## 5、Condition接口

Codition类似于java对象的监视器方法，如wait()、wait(long timeout)、notify()以及notifyAll()等，这些方法与synchronized关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有区别的，如下：

| 对比项                                               | Object monitor methods | Condition                                                    |
| ---------------------------------------------------- | ---------------------- | ------------------------------------------------------------ |
| 前置条件                                             | 获取对象锁             | 调用Lock.lock()获取锁\t调用Lock.newCondition()获取Condition对象 |
| 调用方式                                             | object.wait()          | condition.await()                                            |
| 等待队列个数                                         | 一个                   | 多个                                                         |
| 当前线程释放锁并进入等待状态                         | 支持                   | 支持                                                         |
| 当前线程释放锁并进入等待状态，在等待状态中不响应中断 | 不支持                 | 支持                                                         |
| 当前线程释放锁并进入超时等待状态                     | 支持                   | 支持                                                         |
| 当前线程释放锁并进入等待状态到将来的某个时间         | 不支持                 | 支持                                                         |
| 唤醒等待队列中的一个线程                             | 支持                   | 支持                                                         |
| 唤醒等待队列中的全部线程                             | 支持                   | 支持                                                         |

实现原理：

1）等待队列：

等待队列是一个FIFO队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程就会释放锁，构造成节点加入等待队列并进入等待状态。

2）等待：

调用Condition的await()（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。

如果从队列的角度开await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到Condition的等待队列中

3）通知

调用Condition中的signal()方法，将会唤醒在等待队列总等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。



