# 一、线程池的实现原理

线程池的处理流程如下：

1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程

2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作对立里。如果工作队列满了，则进入下个流程

3、线程池判断线程池的线程都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务

线程池中的线程执行任务分两种情况，如下：

1、在executor()方法中创建一个线程时，会让这个线程执行当前任务

2、这个线程执行完1步骤中接收的任务后，会反复从BlockQueue获取任务来执行

# 二、向线程池提交任务

可以使用两个方法向线程池提交任务，分别为execute()和submit()方法

## 1、execute()

用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功

## 2、submit()

用于提交需要返回值的任务，线程池会返回一个future类型的对象

# 三、关闭线程池

可以通过调用线程池的shutdown()和shutdownNow()方法来关闭线程池。它们的原理是遍历线程池中的龚总线程然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。

shutdown和shutdownNow方法的区别：

shutdownNow首先将线程池的状态设置成STOP然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHTUTDOWN状态，然后中断所有没有正在执行任务的线程

只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都关闭后，才表示线程池关闭成功，这时调用isTerminated方法会返回true

# 四、合理地配置线程池

CPU密集型任务应该配置尽可能小的线程，如配置N~CPU~+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则因该配置尽可能多的线程，如2*N~CPU~。混合型任务，如果可以拆分，将其拆分成一个CPU密集型任务和IO密集型任务，只要这两个任务的执行时间相差不是太大，那么分解后执行的吞吐量将高于串行之行的吞吐量

处理器数量可以通过`Runtime.getRuntime().availableProcessors()`方法获得

