# 一、相关概念

## 1、生产者和消费者

**Producer：**生产者，就是消息投递的一方

消息一般可以包含两个部分：消息体和标签，消息体一般是一个带有实际业务逻辑结构的数据，比如一个JSON字符串。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者

**Consumer：**消费者，就是接收消息的一方

当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁

**Broker：**

一个RabbitMQ Broker可以简单地看做一个RabbitMQ服务节点，或者RabbitMQ服务实例

## 2、队列

**Queue：**队列，时RabbitMQ的内部对象，用于存储消息

多个消费者可以订阅到同一个队列，这时队列中的消息会被平均分摊（轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理

## 3、交换器、路由键、绑定

**Exchange：**交换器，生产者将消息发送到Exchange，由交换器将消息路由到一个活多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃

**RoutingKey：**路由键。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定建联合使用才能最终生效

**Binding：**RabbitMQ中通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定建，这样RabbitMQ就知道如何正确地将消息路由到队列了

**注：**在direct类型下，RoutingKey和BindingKey可以使用同一个Key，因为direct类型交换器下，RoutingKey和BindingKey需要完全匹配才能使用；但是在topic类型交换器下，RoutingKey和BindingKey之间需要做模糊匹配，两者并不是相同的

为了避免混淆RoutingKey和BindingKey，可以这么理解：

- 在使用绑定的时候，其中需要的路由键是BindingKey
- 在发送消息的时候，其中需要的路由键是RoutingKey

## 4、交换器类型

RabbitMQ常用的交换器类型有fanout、direct、topic、headers四中，AMQP协议中还提到了另外两种：System和自定义。

### 1）fanout

它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中

### 2）direct

dirext类型交换器路由规则也很简单，他会把消息 路由到那些BindingKey和RoutingKey完全匹配的队列中

### 3）topic

topic类型的交换器与direct类型的交换器相似，也是讲消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定：

- RoutingKey为一个点号“.”分隔的字符串，如“com.rabbitmq.client”
- BindingKey和RoutingKey一样也是点号“.”分隔的字符串
- BindingKey中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中 “ *”用于匹配一个单子，“#”用于匹配多规格单子（可以是零个）

### 4）headers

headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容找那个的headers属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在

## 5、RabbitMQ的运转流程

#### 1）消费者发送消息流程：

（1）生产者连接到RabbitMQ Broker，建立一个连接，病开启一个信道

（2）生产者生命一个交换器，并设置一个相关属性，比如交换器类型、是否持久化等

（3）生产者生命一个队列并设置相关属性，比如是否排他、是否持久化、是否自动删除等

（4）生产者通过路由键讲交换器和队列绑定起来

（5）生产者发送消息至RabbitMQ Broker，其中包括路由键、交换器等类型

（6）相应的交换器根据接收到的路由键查找匹配的队列

（7）如果找到了，则将从生产者发送过来的消息存入相应的队列中

（8）如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者

（9）关闭信道

（10）关闭连接

## 2）消费者接收消息的过程：

（1）消费者连接到RabbitMQ Broker，建立一个连接，开启一个信道

（2）消费者向RabbitMQ Broker请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作

（3）等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接收消息

（4）消费者确认接收的消息

（5）RabbitMQ从队列中删除相应已经被确认的消息

（6）关闭信道

（7）关闭连接

为什么要引入信道？

如果一个程序中的多个线程需要从RabbitMQ中消费消息，或者生产消息，那么比人需要建立很多个Connection，也就是许多个TCP连接。然而这对操作系统而言，建立和销毁TCP连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMQ采用类似NIO的做法，选择TCP连接服用，不仅可以减少性能开销，同时也便于管理 

5、RabbitMQ的运转流程



