Dubbo采用软负载均衡的方式，来处理服务的分发，负载均衡也是采用插件的形式实现，Dubbo中默认的负载均衡实现方式有四种，分别是随机、轮询、最小活跃数、一致性哈希。默认采用随机负载均衡方式，如果以上四种方式不满足需求，用户也可以自己实现。

Dubbo中负载均衡的类图结构如下：

![](../pictures/Dubbo_负载均衡类图.png)

目前最新版本（2.7.x）中的`MockLoadBalance`还没有具体实现，我们主要关注`AbstractLoanBalance`以及其实现类就可以

**问题：** 如果对于`FailoverClusterInvoker`，在第一次失败后，重新选择第二个可调用服务，在负载均衡中计算权重的时候，如果因为临时修改权重导致负载均衡又选择了第一次调用失败的服务，这个时候怎么办？

**答：** 在`FailoverClusterInvoker`中，如果第一次调用失败，在选择第二个可调用服务的时候，如果因为服务全中值发生变化导致又选择到第一个调用失败的服务，这个时候会触发reselect，即重新选择，其逻辑是：选择该服务所在列表索引的下一个位置的服务进行调用。实际上触发`FailoverClusterInvoker`重新选择的不止这一个因素，譬如可调用服务列表发生变化，也会进行重新选择

## 1、随机负载均衡：

Dubbo中的随机负载均衡，实际上应该叫加权随机负载均衡，Dubbo给每个可调用的服务添加了一个负载因子，通过负载因此来调整每个可调用服务的随机权重，默认情况下，每个可调用服务的权重为100，用户也可以在Dubbo控制台调整权重值

其处理逻辑如下图所示：

![](../pictures/Dubbo_随机负载均衡流程图.png)

**描述：**

a、遍历服务列表

b、获取每个服务的权重值

c、对比每个服务的权重值，若权重值相等，则取服务总数的随机数，获取到的随机数就是最终获取到的服务在列表中的索引，若权重值不相等，则跳到步骤d

d、计算所有服务权重值的总和

e、再次遍历服务列表

f、取得d步骤计算出来的总权重值的随机数

g、计算每个服务的权重值与f计算得到的随机数的差值

h、若g计算的差值为负，则该服务就是要取得的服务，否则，回退到g步骤，直到差值为负

i、返回取得服务

## 2、轮询负载均衡

Dubbo中的轮询负载均衡策略，实际上也是加权轮询负载均衡，Dubbo根据每个服务的权重值来控制轮询的先后顺序,如果权重值相等，则从列表中的第一个元素开始轮询，如果权重值不等，则从权重值最大的元素开始轮询。Dubbo的轮询算法中有几个变量：

- 原始权重值 $ot$（Dubbo控制台设置的初始值）

- 动态权重值 $DT$（轮询算法中动态计算的权重值），该值的计算方法：如果当前服务在该轮轮询中没有被选中，则该值在原值的基础上加原始权重值，其如果被选中了，那么这个服务的动态权重值等于原值减去总权重值，动态权重值是决定该服务最终被选择的依据，计算公式如下：

  ​							$$DT[r] =\begin{cases} DT[r-1] + ot,未被选中\\ DT[r-1]-st,被选中\end{cases}$$

  其中，$DT[r-1]$ 表示上一轮轮询后的动态权重值

  动态权重值$DT$的区间范围为：

  ​                                                        $DT \leq |st| $

- 总权重值 $st$：服务列表中所有服务的原始权重值的总，计算公式如下：

  ​							$st = \sum_{i=0}^{n-1} ot[i]$

- 当前最大权重值，这个值实际上就是服务列表中最大的动态权重值

- 已被选择的服务，最终的服务就是这个服务，实际上，这个值在轮询的过程中是发生变化的，该值是所有服务的动态权重值最大的那个服务

轮询负载均衡的处理逻辑如下图所示：![](../pictures/Dubbo_轮询负载均衡流程图.png)

**描述：**



